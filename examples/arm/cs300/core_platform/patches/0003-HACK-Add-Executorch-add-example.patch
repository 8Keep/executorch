From 3541125ad346b3fd237c414b4da8a1ee1c15b8d8 Mon Sep 17 00:00:00 2001
From: Digant Desai <digantdesai@meta.com>
Date: Thu, 28 Sep 2023 19:07:51 -0700
Subject: [PATCH 3/3] [HACK] Add Executorch add example

---
 applications/CMakeLists.txt                  |   2 +
 applications/executorch_tests/CMakeLists.txt |  53 ++++++++
 applications/executorch_tests/add.cpp        | 126 +++++++++++++++++++
 cmake/helpers.cmake                          |  13 +-
 4 files changed, 192 insertions(+), 2 deletions(-)
 create mode 100644 applications/executorch_tests/CMakeLists.txt
 create mode 100644 applications/executorch_tests/add.cpp

diff --git a/applications/CMakeLists.txt b/applications/CMakeLists.txt
index 1fa2b2e..68e5427 100644
--- a/applications/CMakeLists.txt
+++ b/applications/CMakeLists.txt
@@ -28,6 +28,8 @@ add_subdirectory(threadx_demo)
 
 add_subdirectory(message_handler_openamp)
 
+add_subdirectory(executorch_tests)
+
 if (CMAKE_CXX_COMPILER_ID STREQUAL "ARMClang")
     # Only armclang supported for now
     add_subdirectory(trustzone_inference)
diff --git a/applications/executorch_tests/CMakeLists.txt b/applications/executorch_tests/CMakeLists.txt
new file mode 100644
index 0000000..456bb31
--- /dev/null
+++ b/applications/executorch_tests/CMakeLists.txt
@@ -0,0 +1,53 @@
+#
+# Copyright (c) 2021 Arm Limited. All rights reserved.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+# Licensed under the Apache License, Version 2.0 (the License); you may
+# not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an AS IS BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+if (NOT TARGET ethosu_core_driver)
+  return()
+endif()
+
+####
+#### Executorch demo app/test
+####
+
+set(ET_DIR_PATH "<..>/executorch" CACHE PATH "Path to Executorch dir")
+set(ET_BUILD_DIR_PATH "${ET_DIR_PATH}/cmake-out" CACHE PATH "Path to Executorch build dir")
+set(ET_INCLUDE_PATH "${ET_DIR_PATH}/.." CACHE PATH "Path to Executorch headers")
+
+get_filename_component(ET_BUILD_DIR_PATH ${ET_BUILD_DIR_PATH} REALPATH)
+get_filename_component(ET_DIR_PATH ${ET_DIR_PATH} REALPATH)
+get_filename_component(ET_INCLUDE_PATH ${ET_INCLUDE_PATH} REALPATH)
+
+message("**********************")
+message("Executorch dir      (ET_DIR_PATH)      : ${ET_DIR_PATH}")
+message("Executorch build dir(ET_BUILD_DIR_PATH): ${ET_BUILD_DIR_PATH}")
+message("Executorch headers  (ET_INCUDE_PATH)   : ${ET_INCLUDE_PATH}")
+message("**********************")
+
+set(LIB_ET_RUNTIME "${ET_BUILD_DIR_PATH}/libexecutorch.a")
+set(LIB_ET_OP_REGISTRATION "${ET_BUILD_DIR_PATH}/kernels/portable/libportable_ops_lib.a")
+set(LIB_ET_OP_KERNELS "${ET_BUILD_DIR_PATH}/kernels/portable/libportable_kernels.a")
+
+ethosu_add_executable_test(executorch_add PRIVATE
+    WHOLE_ARCHIVE TRUE
+    SOURCES add.cpp
+    LIBRARIES ${LIB_ET_RUNTIME} ${LIB_ET_OP_REGISTRATION} ${LIB_ET_OP_KERNELS})
+
+target_include_directories(executorch_add PRIVATE
+${ET_INCLUDE_PATH})
+
+# TODO Memory setup
diff --git a/applications/executorch_tests/add.cpp b/applications/executorch_tests/add.cpp
new file mode 100644
index 0000000..acbdb3d
--- /dev/null
+++ b/applications/executorch_tests/add.cpp
@@ -0,0 +1,126 @@
+/*
+ * SPDX-FileCopyrightText: Copyright 2021-2023 Arm Limited and/or its affiliates <open-source-office@arm.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the License); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/****************************************************************************
+ * Includes
+ ****************************************************************************/
+
+#include <stdio.h>
+
+#include <executorch/runtime/platform/runtime.h>
+#include <executorch/runtime/executor/program.h>
+#include <executorch/extension/data_loader/buffer_data_loader.h>
+#include <executorch/runtime/platform/log.h>
+#include <executorch/util/util.h>
+
+#include <executorch/add.pte.h>
+
+#include <vector>
+#include <memory>
+
+using namespace std;
+
+__attribute__((section(".sram.data"), aligned(16))) uint8_t method_allocator_pool[4 * 1024U];
+
+/****************************************************************************
+ * Functions
+ ****************************************************************************/
+
+int main() {
+     /*
+      * This is a simple Executorch app which runs `add.pte`.
+      */
+
+    torch::executor::runtime_init();
+
+    using torch::executor::Result;
+    using torch::executor::Error;
+
+    auto loader = torch::executor::util::BufferDataLoader(add_pte, sizeof(add_pte));
+
+    Result<torch::executor::Program> program = torch::executor::Program::load(&loader);
+    if(!program.ok()) {
+       ET_LOG(Info,"ET: Program loading failed @ 0x%p: 0x%" PRIx32, add_pte, program.error());
+    }
+
+    ET_LOG(Info,"ET: Model buffer loaded, has %lu methods", program->num_methods());
+
+    const char* method_name = nullptr;
+    {
+      const auto method_name_result = program->get_method_name(0);
+      ET_CHECK_MSG(method_name_result.ok(), "Program has no methods");
+      method_name = *method_name_result;
+    }
+    ET_LOG(Info,"ET: Running method %s", method_name);
+
+    Result<torch::executor::MethodMeta> method_meta = program->method_meta(method_name);
+    if (!method_meta.ok()) {
+        ET_LOG(Info,"ET: Failed to get method_meta for %s: 0x%x",
+                method_name, (unsigned int)method_meta.error());
+    }
+
+    torch::executor::MemoryAllocator method_allocator{
+        torch::executor::MemoryAllocator(sizeof(method_allocator_pool), method_allocator_pool)};
+
+    std::vector<std::unique_ptr<uint8_t[]>> planned_buffers; // Owns the memory
+    std::vector<torch::executor::Span<uint8_t>> planned_spans; // Passed to the allocator
+    size_t num_memory_planned_buffers = method_meta->num_memory_planned_buffers();
+
+    for (size_t id = 0; id < num_memory_planned_buffers; ++id) {
+        size_t buffer_size = static_cast<size_t>(method_meta->memory_planned_buffer_size(id).get());
+        ET_LOG(Info,"ET: Setting up planned buffer %zu, size %zu.", id, buffer_size);
+
+        planned_buffers.push_back(std::make_unique<uint8_t[]>(buffer_size));
+        planned_spans.push_back({planned_buffers.back().get(), buffer_size});
+    }
+
+    torch::executor::HierarchicalAllocator planned_memory(
+      {planned_spans.data(), planned_spans.size()});
+
+    torch::executor::MemoryManager memory_manager(&method_allocator, &planned_memory);
+
+    Result<torch::executor::Method> method = program->load_method(method_name, &memory_manager);
+    if(!method.ok()) {
+        ET_LOG(Info,"ET: Loading of method %s failed with status 0x%" PRIx32, method_name, method.error());
+    }
+    ET_LOG(Info,"ET: Method loaded.");
+
+    ET_LOG(Info,"ET: Preparing inputs...");
+    auto inputs = torch::executor::util::PrepareInputTensors(*method);
+    ET_LOG(Info,"ET: Input prepared.");
+
+    ET_LOG(Info,"ET: Starting the model execution...");
+    Error status = method->execute();
+    if(status != Error::Ok){
+        ET_LOG(Info,"ET: Execution of method %s failed with status 0x%" PRIx32, method_name, status);
+    } else {
+        ET_LOG(Info,"ET: Model executed successfully.");
+    }
+
+    // Print the outputs.
+    std::vector<torch::executor::EValue> outputs(method->outputs_size());
+    ET_LOG(Info, "%zu outputs: ", outputs.size());
+    status = method->get_outputs(outputs.data(), outputs.size());
+    ET_CHECK(status == Error::Ok);
+    for (int i = 0; i < outputs.size(); ++i) {
+       for (int j = 0; j < outputs[i].toTensor().numel(); ++j) {
+          printf("Output[%d][%d]: %f\n", i, j, outputs[i].toTensor().const_data_ptr<float>()[j]);
+       }
+    }
+    return 0;
+}
diff --git a/cmake/helpers.cmake b/cmake/helpers.cmake
index a21d9f0..036f189 100644
--- a/cmake/helpers.cmake
+++ b/cmake/helpers.cmake
@@ -85,7 +85,7 @@ endfunction()
 #############################################################################
 
 function(ethosu_add_executable target)
-    cmake_parse_arguments(ARGS "" "TARGET_LIBRARY" "SOURCES;LIBRARIES" ${ARGN})
+    cmake_parse_arguments(ARGS "WHOLE_ARCHIVE" "TARGET_LIBRARY" "SOURCES;LIBRARIES" ${ARGN})
     add_executable(${target})
 
     target_sources(${target} PRIVATE
@@ -95,8 +95,17 @@ function(ethosu_add_executable target)
         set(ARGS_TARGET_LIBRARY ethosu_target_init)
     endif()
 
+    if (ARGS_WHOLE_ARCHIVE)
+        set(PRE_LINKER_FLAGS "-Wl,--whole-archive")
+        set(POST_LINKER_FLAGS "-Wl,--no-whole-archive")
+    endif()
+
     target_link_libraries(${target} PRIVATE
-        ${ARGS_TARGET_LIBRARY} ${ARGS_LIBRARIES})
+        ${PRE_LINKER_FLAGS}
+        ${ARGS_TARGET_LIBRARY} 
+        ${ARGS_LIBRARIES}
+        ${POST_LINKER_FLAGS}
+        )
 
     ethosu_eval_link_options(${target})
 
-- 
2.39.3

